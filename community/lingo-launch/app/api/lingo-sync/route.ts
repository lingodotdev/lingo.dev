import { NextResponse } from 'next/server';
import fs from 'fs';
import path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';

const execAsync = promisify(exec);

export async function POST(req: Request) {
    try {
        const { texts } = await req.json();

        if (!Array.isArray(texts) || texts.length === 0) {
            return NextResponse.json({ message: 'No texts provided' }, { status: 400 });
        }

        // Generate the dummy source file content
        // We import useLingo but don't use the hook or component logic, just static t() calls
        // so the compiler picks them up.
        // Actually, lingo might need a valid react component structure.
        const fileContent = `
// This file is auto-generated by LingoLaunch to enable dynamic content translation.
// Do not edit manually.
import { useLingo } from '@lingo.dev/compiler/react';

export default function LingoDynamicSource() {
  const { t } = useLingo();
  
  return (
    <>
      ${texts.map(text => `{/* @ts-ignore */}\n      {t("${text.replace(/"/g, '\\"')}")}`).join('\n      ')}
    </>
  );
}
`;

        const filePath = path.join(process.cwd(), 'app', 'lingo-dynamic-source.tsx');

        // Write the file
        fs.writeFileSync(filePath, fileContent, 'utf-8');

        // Run lingo run
        // Using npx lingo run. Assuming it's available in the environment.
        // We might need to handle the output/error.
        // CWD should be project root.
        const { stdout, stderr } = await execAsync('npx lingo run', { cwd: process.cwd() });

        console.log('Lingo Run Output:', stdout);
        if (stderr) console.error('Lingo Run Error:', stderr);

        return NextResponse.json({ success: true, message: 'Translations updated' });
    } catch (error) {
        console.error('Error in lingo-sync:', error);
        return NextResponse.json({ error: 'Failed to sync translations' }, { status: 500 });
    }
}
