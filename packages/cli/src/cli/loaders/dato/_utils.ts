import _ from "lodash";
import { buildClient, SimpleSchemaTypes } from "@datocms/cma-client-node";
import { DastDocument, DatoBlock, DatoSimpleValue, DatoValue } from "./_base";
import { DastDocumentNode } from "./_base";

type DatoClientParams = {
  apiKey: string;
  projectId: string;
};

export type DatoClient = ReturnType<typeof createDatoClient>;

export default function createDatoClient(params: DatoClientParams) {
  if (!params.apiKey) {
    throw new Error(
      "Missing required environment variable: DATO_API_TOKEN. Please set this variable and try again.",
    );
  }
  const dato = buildClient({
    apiToken: params.apiKey,
    extraHeaders: {
      "X-Exclude-Invalid": "true",
    },
  });

  return {
    findProject: async (): Promise<SimpleSchemaTypes.Site> => {
      const project = await dato.site.find();
      return project;
    },
    updateField: async (
      fieldId: string,
      payload: SimpleSchemaTypes.FieldUpdateSchema,
    ): Promise<void> => {
      try {
        await dato.fields.update(fieldId, payload);
      } catch (_error: any) {
        throw new Error(
          [
            `Failed to update field in DatoCMS.`,
            `Field ID: ${fieldId}`,
            `Payload: ${JSON.stringify(payload, null, 2)}`,
            `Error: ${JSON.stringify(_error, null, 2)}`,
          ].join("\n\n"),
        );
      }
    },
    findField: async (fieldId: string): Promise<SimpleSchemaTypes.Field> => {
      try {
        const field = await dato.fields.find(fieldId);
        if (!field) {
          throw new Error(`Field ${fieldId} not found`);
        }
        return field;
      } catch (_error: any) {
        throw new Error(
          [
            `Failed to find field in DatoCMS.`,
            `Field ID: ${fieldId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`,
          ].join("\n\n"),
        );
      }
    },
    findModels: async (): Promise<SimpleSchemaTypes.ItemType[]> => {
      try {
        const models = await dato.itemTypes.list();
        const modelsWithoutBlocks = models.filter(
          (model) => !model.modular_block,
        );
        return modelsWithoutBlocks;
      } catch (_error: any) {
        throw new Error(
          [
            `Failed to find models in DatoCMS.`,
            `Error: ${JSON.stringify(_error, null, 2)}`,
          ].join("\n\n"),
        );
      }
    },
    findModel: async (modelId: string): Promise<SimpleSchemaTypes.ItemType> => {
      try {
        const model = await dato.itemTypes.find(modelId);
        if (!model) {
          throw new Error(`Model ${modelId} not found`);
        }
        return model;
      } catch (_error: any) {
        throw new Error(
          [
            `Failed to find model in DatoCMS.`,
            `Model ID: ${modelId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`,
          ].join("\n\n"),
        );
      }
    },
    findRecords: async (
      records: string[],
      limit: number = 100,
    ): Promise<SimpleSchemaTypes.Item[]> => {
      return dato.items
        .list({
          nested: true,
          version: "current",
          limit,
          filter: {
            projectId: params.projectId,
            only_valid: "true",
            ids: !records.length ? undefined : records.join(","),
          },
        })
        .catch((error: any) =>
          Promise.reject(error?.response?.body?.data?.[0] || error),
        );
    },
    findRecordsForModel: async (
      modelId: string,
      records?: string[],
    ): Promise<SimpleSchemaTypes.Item[]> => {
      try {
        const result = await dato.items
          .list({
            nested: true,
            version: "current",
            filter: {
              type: modelId,
              only_valid: "true",
              ids: !records?.length ? undefined : records.join(","),
            },
          })
          .catch((error: any) =>
            Promise.reject(error?.response?.body?.data?.[0] || error),
          );
        return result;
      } catch (_error: any) {
        throw new Error(
          [
            `Failed to find records for model in DatoCMS.`,
            `Model ID: ${modelId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`,
          ].join("\n\n"),
        );
      }
    },
    updateRecord: async (id: string, payload: any): Promise<void> => {
      try {
        await dato.items
          .update(id, payload)
          .catch((error: any) =>
            Promise.reject(error?.response?.body?.data?.[0] || error),
          );
      } catch (_error: any) {
        if (_error?.attributes?.details?.message) {
          throw new Error(
            [
              `${_error.attributes.details.message}`,
              `Payload: ${JSON.stringify(payload, null, 2)}`,
              `Error: ${JSON.stringify(_error, null, 2)}`,
            ].join("\n\n"),
          );
        }

        throw new Error(
          [
            `Failed to update record in DatoCMS.`,
            `Record ID: ${id}`,
            `Payload: ${JSON.stringify(payload, null, 2)}`,
            `Error: ${JSON.stringify(_error, null, 2)}`,
          ].join("\n\n"),
        );
      }
    },
    enableFieldLocalization: async (args: {
      modelId: string;
      fieldId: string;
    }): Promise<void> => {
      try {
        await dato.fields
          .update(`${args.modelId}::${args.fieldId}`, { localized: true })
          .catch((error: any) =>
            Promise.reject(error?.response?.body?.data?.[0] || error),
          );
      } catch (_error: any) {
        if (_error?.attributes?.code === "NOT_FOUND") {
          throw new Error(
            [
              `Field "${args.fieldId}" not found in model "${args.modelId}".`,
              `Error: ${JSON.stringify(_error, null, 2)}`,
            ].join("\n\n"),
          );
        }

        if (_error?.attributes?.details?.message) {
          throw new Error(
            [
              `${_error.attributes.details.message}`,
              `Error: ${JSON.stringify(_error, null, 2)}`,
            ].join("\n\n"),
          );
        }

        throw new Error(
          [
            `Failed to enable field localization in DatoCMS.`,
            `Field ID: ${args.fieldId}`,
            `Model ID: ${args.modelId}`,
            `Error: ${JSON.stringify(_error, null, 2)}`,
          ].join("\n\n"),
        );
      }
    },
  };
}

type TraverseDatoCallbackMap = {
  onValue?: (
    path: string[],
    value: DatoSimpleValue,
    setValue: (value: DatoSimpleValue) => void,
  ) => void;
  onBlock?: (path: string[], value: DatoBlock) => void;
};

export function traverseDatoPayload(
  payload: Record<string, DatoValue>,
  callbackMap: TraverseDatoCallbackMap,
  path: string[] = [],
) {
  for (const fieldName of Object.keys(payload)) {
    const fieldValue = payload[fieldName];
    traverseDatoValue(payload, fieldValue, callbackMap, [...path, fieldName]);
  }
}

export function traverseDatoValue(
  parent: Record<string, DatoValue>,
  value: DatoValue,
  callbackMap: TraverseDatoCallbackMap,
  path: string[] = [],
) {
  if (_.isArray(value)) {
    for (let i = 0; i < value.length; i++) {
      traverseDatoValue(parent, value[i], callbackMap, [...path, i.toString()]);
    }
  } else if (_.isObject(value)) {
    if ("schema" in value && value.schema === "dast") {
      traverseDastDocument(value, callbackMap, [...path]);
    } else if ("type" in value && value.type === "item") {
      traverseDatoBlock(value, callbackMap, [...path]);
    } else {
      throw new Error(
        [
          "Unsupported dato object value type:",
          JSON.stringify(value, null, 2),
        ].join("\n\n"),
      );
    }
  } else {
    callbackMap.onValue?.(path, value, (value) => {
      _.set(parent, path[path.length - 1], value);
    });
  }
}

export function traverseDastDocument(
  dast: DastDocument,
  callbackMap: TraverseDatoCallbackMap,
  path: string[] = [],
) {
  traverseDastNode(dast.document, callbackMap, [...path, "document"]);
}

export function traverseDatoBlock(
  block: DatoBlock,
  callbackMap: TraverseDatoCallbackMap,
  path: string[] = [],
) {
  callbackMap.onBlock?.(path, block);
  traverseDatoPayload(block.attributes, callbackMap, [...path, "attributes"]);
}

export function traverseDastNode(
  node: DastDocumentNode,
  callbackMap: TraverseDatoCallbackMap,
  path: string[] = [],
) {
  if (node.value) {
    callbackMap.onValue?.(path, node.value, (value) => {
      _.set(node, "value", value);
    });
  }
  if (node.children?.length) {
    for (let i = 0; i < node.children.length; i++) {
      traverseDastNode(node.children[i], callbackMap, [...path, i.toString()]);
    }
  }
}
